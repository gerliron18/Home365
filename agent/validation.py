"""
Answer Validation Module
========================
Validates LLM-generated answers against SQL results to prevent hallucinations.
"""

import re
from typing import Any, List, Tuple, Optional


class AnswerValidator:
    """Validates that LLM answers match SQL results"""
    
    @staticmethod
    def extract_numbers(text: str) -> List[float]:
        """
        Extract all numbers from text, ignoring street addresses
        
        Args:
            text: Text to extract numbers from
            
        Returns:
            List of numbers found in text
        """
        if not text:
            return []
        
        # First, remove street address patterns to avoid false positives
        # Patterns like "1234 W Main St" or "123 Oak Ave"
        address_patterns = [
            r'\b\d+\s+[NSEW]\s+\w+\s+(?:St|Street|Ave|Avenue|Rd|Road|Blvd|Boulevard|Dr|Drive|Ln|Lane|Way|Ct|Court|Pl|Place)\b',
            r'\b\d+\s+\w+\s+(?:St|Street|Ave|Avenue|Rd|Road|Blvd|Boulevard|Dr|Drive|Ln|Lane|Way|Ct|Court|Pl|Place)\b',
        ]
        
        cleaned_text = str(text)
        for pattern in address_patterns:
            cleaned_text = re.sub(pattern, '', cleaned_text, flags=re.IGNORECASE)
        
        # Pattern matches: integers, decimals, numbers with commas
        pattern = r'\$?(?:\d{1,3}(?:,\d{3})*|\d+)(?:\.\d+)?'
        matches = re.findall(pattern, cleaned_text)
        
        numbers = []
        for match in matches:
            # Remove $ and commas
            cleaned = match.replace('$', '').replace(',', '')
            try:
                numbers.append(float(cleaned))
            except ValueError:
                continue
        
        return numbers
    
    @staticmethod
    def extract_sql_numbers(sql_result: Any) -> List[float]:
        """
        Extract numbers from SQL result
        
        Args:
            sql_result: SQL query result (list of tuples, dict, or single value)
            
        Returns:
            List of numbers found in SQL result
        """
        numbers = []
        
        if sql_result is None:
            return numbers
        
        # Handle different result types
        if isinstance(sql_result, (int, float)):
            numbers.append(float(sql_result))
        
        elif isinstance(sql_result, list):
            for row in sql_result:
                if isinstance(row, (int, float)):
                    numbers.append(float(row))
                elif isinstance(row, (tuple, list)):
                    for val in row:
                        if isinstance(val, (int, float)):
                            numbers.append(float(val))
                elif isinstance(row, dict):
                    for val in row.values():
                        if isinstance(val, (int, float)):
                            numbers.append(float(val))
        
        elif isinstance(sql_result, dict):
            for val in sql_result.values():
                if isinstance(val, (int, float)):
                    numbers.append(float(val))
        
        return numbers
    
    @staticmethod
    def numbers_match(num1: float, num2: float, tolerance: float = 0.02) -> bool:
        """
        Check if two numbers match within tolerance
        
        Args:
            num1: First number
            num2: Second number
            tolerance: Relative tolerance (default 2%)
            
        Returns:
            True if numbers match within tolerance
        """
        if num1 == num2:
            return True
        
        # Handle zero case
        if num1 == 0 or num2 == 0:
            return abs(num1 - num2) < 0.01
        
        # Calculate relative difference
        relative_diff = abs(num1 - num2) / max(abs(num1), abs(num2))
        return relative_diff <= tolerance
    
    @classmethod
    def validate_answer(
        cls,
        sql_result: Any,
        llm_answer: str,
        tolerance: float = 0.02
    ) -> Tuple[bool, Optional[str], float]:
        """
        Validate that LLM answer matches SQL result
        
        Args:
            sql_result: Result from SQL query execution
            llm_answer: Answer generated by LLM
            tolerance: Tolerance for numeric comparisons (default 2%)
            
        Returns:
            Tuple of (is_valid, warning_message, confidence_score)
            - is_valid: True if answer matches SQL result
            - warning_message: Warning message if validation fails, None otherwise
            - confidence_score: Confidence in the answer (0.0 to 1.0)
        """
        # Extract numbers from both sources
        sql_numbers = cls.extract_sql_numbers(sql_result)
        answer_numbers = cls.extract_numbers(llm_answer)
        
        # If no numbers in answer, assume it's valid (descriptive answer)
        if not answer_numbers:
            return True, None, 1.0
        
        # If no numbers in SQL result but numbers in answer, flag as suspicious
        if not sql_numbers and answer_numbers:
            warning = (
                f"âš ï¸ VALIDATION WARNING: Answer contains numbers {answer_numbers} "
                f"but SQL returned no numeric data. Please verify manually."
            )
            return False, warning, 0.4
        
        # Check if all key numbers in answer match SQL results
        unmatched_numbers = []
        matched_count = 0
        
        for ans_num in answer_numbers:
            found_match = False
            for sql_num in sql_numbers:
                if cls.numbers_match(ans_num, sql_num, tolerance):
                    found_match = True
                    matched_count += 1
                    break
            
            if not found_match:
                unmatched_numbers.append(ans_num)
        
        # If any numbers don't match, validation fails
        if unmatched_numbers:
            warning = (
                f"âš ï¸ VALIDATION WARNING: Numbers {unmatched_numbers} in answer "
                f"don't match SQL results {sql_numbers}. Possible hallucination detected."
            )
            # Confidence based on match ratio
            confidence = matched_count / len(answer_numbers) if answer_numbers else 0.5
            return False, warning, max(0.3, confidence)
        
        # All numbers match
        return True, None, 1.0
    
    @classmethod
    def format_validated_answer(
        cls,
        answer: str,
        is_valid: bool,
        warning: Optional[str],
        confidence: float,
        sql_result: Any = None
    ) -> str:
        """
        Format answer with validation metadata
        Only shows warnings when confidence < 0.75 (high chance of hallucination)
        
        Args:
            answer: Original LLM answer
            is_valid: Whether validation passed
            warning: Warning message if validation failed
            confidence: Confidence score (0.0 to 1.0)
            sql_result: Original SQL result (optional, for debugging)
            
        Returns:
            Formatted answer with validation info
        """
        parts = [answer]
        
        # Only show warnings if confidence is below 25% (>75% hallucination risk)
        # confidence < 0.25 means hallucination_probability > 0.75
        if not is_valid and warning and confidence < 0.25:
            parts.append(f"\n{warning}")
        
            # Add confidence indicator for low confidence answers
            if confidence >= 0.5:
                confidence_emoji = "ðŸŸ¡"
                confidence_label = "MEDIUM"
            else:
                confidence_emoji = "ðŸ”´"
                confidence_label = "LOW"
            
            parts.append(
                f"\n{confidence_emoji} Confidence: {confidence_label} "
                f"({confidence*100:.0f}%)"
            )
        
            # Add raw SQL result if validation failed (for transparency)
            if sql_result is not None:
                parts.append(f"\nðŸ“Š Raw SQL Result: {sql_result}")
        
        return "\n".join(parts)
    
    @classmethod
    def validate_and_format(
        cls,
        sql_result: Any,
        llm_answer: str,
        tolerance: float = 0.02,
        include_raw_result: bool = False
    ) -> Tuple[str, bool, float]:
        """
        Convenience method: validate and format answer in one call
        
        Args:
            sql_result: Result from SQL query
            llm_answer: Answer from LLM
            tolerance: Numeric tolerance for validation
            include_raw_result: Whether to include raw SQL result on failure
            
        Returns:
            Tuple of (formatted_answer, is_valid, confidence)
        """
        is_valid, warning, confidence = cls.validate_answer(
            sql_result, llm_answer, tolerance
        )
        
        formatted_answer = cls.format_validated_answer(
            llm_answer,
            is_valid,
            warning,
            confidence,
            sql_result if include_raw_result else None
        )
        
        return formatted_answer, is_valid, confidence
